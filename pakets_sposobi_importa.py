''' Пакеты и способы импорта
Чем больше ваш проект, тем выше потребность в наличии пакетов, содержащих другие.
Это создаёт сложную многоуровневую структуру.
Обратите внимание на структуру нашего проекта.
Мы подготовили три пакета: «package1», «package2» и «package3» .
Например, «package1» содержит пакет «package2».
Подпакет (Subpackage) — это пакет, который находится внутри другого пакета,
А «package3» — это подпакет для нашего второго пакета.
Каждый из них содержит определённые файлы.
У нас есть два модуля «module1» и «module2», которые находится внутри «package1» .
Напоминаем, что главный пакет «package1» находится внутри рабочей директории — «lesson_md_4_5».

Представим ситуацию:
у нас есть первый модуль, в котором есть функция, назовём её «hello».
Эта функция принимает имя и выводит, например, ("Привет", name)'''
def hello(name):
    print("Привет", name)

'''Есть второй модуль с функцией «good_word», которая генерирует комплимент и также принимает имя. 
Что мы будем делать внутри этой функции? 
Напишем «Ты лучший» и добавим имя'''
def good_word(name):
    print( 'Ты лучший', name)

'''В первом модуле, соответственно, чтобы все было в одном формате, напишем «Привет» 
У нас есть две функции, находящиеся в разных модулях. 
Давайте во втором модуле проверим кое-что, создав конструкцию «if __name__ == '__main__'», 
которую мы уже рассматривали. 
Внутри этой конструкции мы будем вызывать функцию «good_word», передавая ей имя в качестве аргумента. 
Запускаем код и видим, что всё работает'''
# if __name__ == '__main__':
#     good_word('Урбан')
#
# Ты лучший Урбан

'''Если мы хотим внутри функции «good_word» вызвать также функцию из первого модуля. 
Что нам нужно сделать? Естественно, ее нужно импортировать.'''
# from package1.module1 import hello
#
# def good_word(name):  # отсюда получать
#     hello(name)  # сюда передавать
#     print('Ты лучший', name)
#
#
# if __name__ == '__main__':
#     good_word('Урбан')

'''В первом модуле функция называется «hello», и она также принимает параметр «name». 
Мы будем передавать это имя в функцию «hello» и получать его из функции «good_word»
Предварительно сделать импорт «from package1.module1 import hello»
Запускаем. У нас все работает.'''
# Hello Урбан
# Ты лучший Урбан

'''Сейчас мы использовали абсолютный импорт. Существует два вида импорта:

1. Абсолютный, когда мы полностью указываем путь. То есть изначально мы опираемся на корневую директорию «lesson_md_4_5»;

2. Относительный.

Каковы плюсы абсолютного импорта? 
Когда мы используем абсолютный импорт, у нас не возникает никаких ошибок, 
так как при импорте мы явно указываем, что собираемся взять и откуда. 
Интерпретатор никогда не путается; 
он всегда знает, что мы от него хотим, что просим включить.

Но есть и минусы. 
Допустим, наш проект растёт, и мы увеличиваем количество пакетов, 
т.е. их становится всё больше, появляются более глубокие уровни вложенности. 
Теперь файлы могут находиться внутри «package3» 
Теперь абсолютный путь до функции «hello», которая находится в первом модуле, выглядит иначе. 
Мы сначала указываем «package1», затем «package2», далее «package3», после этого «module1» и говорим «import hello»
Это не хорошо. 
Импорт у нас длинный, что может сделать написание проблематичным, 
потому что уровней вложенности может быть безусловно много. 
У вас может быть и 10 пакетов, и, соответственно, строка импорта будет огромной. 
Пакеты могут называться не так коротко, как у нас, и состоять из нескольких слов. 
Например, «my_project_package_for_...» и так далее, что можно продолжать до бесконечности.'''

#  from package1.ackage2.package3.module1 import hello
'''Естественно, это создает проблему, так как слишком длинная строка делает написание неудобным. 
Это один из недостатков абсолютного импорта.

Но давайте отменим действия. У нас сейчас есть «module1» и «module2», которые находятся внутри «package1».

Что же такое относительный импорт?
Относительный импорт — это использование конструкции «from» с применением точки или двоеточия'''
#  from .module1 import hello

'''Что обозначает точка? 
Точка указывает на текущий каталог. 
Из него мы достаем «module1» и импортируем необходимые элементы. 
Двоеточие обозначает, что мы поднимаемся на уровень выше. 
В нашем случае оба модуля находятся в одном каталоге, поэтому точка подходит для относительного импорта.
Если мы переместим эти два модуля в «package3», они останутся работоспособными, 
потому что здесь действует относительный импорт. 
Ему не важен путь до точки; 
главное, чтобы модули находились в одной директории. 
Мы используем точку, указывая название нашего модуля, и этого достаточно. 
При переносе мы видим, что для них ничего не изменилось'''


'''Однако мы хотим, чтобы все работало. Запускаем и видим ошибку'''
# from .module1 import hello
# ImportError: attempted relative import with no known parent package

(#   from package1.module1 import hello
# ModuleNotFoundError: No module named 'package1.module1')

'''Эта ошибка говорит о том, что наш пакет запускается отсюда как «main». 
Он не видит, где он находится и какой у него родительский пакет, что не позволяет выполнить задачу.
Существуют несколько способов исправить эту проблему. 
Один из них — добавить директории пакетов в переменные среды, то есть в «path». 
Однако это довольно сложный способ. 
Обычно для решения подобных проблем создают точку входа в программу. 
Многие из вас, возможно, когда создавали свои первые проекты, встречали файл «main.py».
«Main.py» расположён там не случайно. 
Обычно в каждом проекте есть файл,
который находится в корневой директории и служит входной точкой для программы.
Давайте создадим такой файл и назовём его «main.py» (Рис. 15, Рис. 16).

Рис.15

Рис.16
Что мы сделаем? Мы укажем абсолютный путь. Нас интересует функция «good_word». Значит, мы берем «package1», затем «package2», затем «package3», откуда импортируем функцию «good_word» из «module2» (Рис. 17).

Рис.17
Далее создаем конструкцию «if __name__ == '__main__'» и вызываем функцию «good_word», передавая ей какое-то значение (Рис. 18, Рис. 19).

Рис.18

Рис.19
Что у нас происходит? Когда мы запускаем конструкцию из основной входной точки нашей программы, проблема с запуском относительных импортов решается, потому что мы знаем, где находится наш проект. Мы явно указываем путь, что помогает интерпретатору лучше понять, где он находится, и проблема с относительными импортами исчезает.

Однако важно учитывать, что когда у нас есть файл запуска «main.py» в корневой директории проекта, для корректной работы мы всегда должны указывать абсолютный путь до этого файла. Это означает, что необходимо полностью указать, откуда вы зашли, куда зашли и что достали. Если вы сталкиваетесь с ошибкой импорта «ImportError», когда не видно родительскую директорию, подумайте внимательно о структуре вашего проекта (Рис. 20). Вероятнее всего, вам нужно создать точку входа в программу в корневой директории и написать логику, которая будет вызывать нужную вам функцию.

Рис.20
Итак, что у нас получается? Сначала мы импортируем функцию «good_word», указывая полный путь, что позволяет нам знать, относительно чего мы ищем «module1» и импортируем вторую функцию «hello».

Для тренировки рекомендую вам поэкспериментировать. Попробуйте создать такую же структуру, как у нас, и перемещаться между пакетами. Например, переместите «module1» не в «package3», а в «package2», на уровень выше, и проверьте, как это будет работать. В результате импорт изменится (Рис. 21).

Рис.21
Но попробуйте сделать относительный импорт и запустить его.'''