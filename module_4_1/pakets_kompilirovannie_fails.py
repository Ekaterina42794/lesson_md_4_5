''' Создание пакетов и компилированные файлы
'Особенности интерпретатора Python и понятие пакета.'

'Особенности интерпретатора Python'
______________________________________________
 Когда мы работаем с модулями и импортируем их, интерпретатор Python полностью считывает информацию,
содержащуюся в этих модулях.
Однако здесь есть одна интересная деталь:
несмотря на то, что Python является интерпретируемым языком программирования,
во время работы с модулями интерпретатор может создавать файлы с расширением ".pyc".
Это происходит в основном в средах разработки, таких как PyCharm, когда мы запускаем файлы с импортами.

В файловой системе (open in --> Explorer) папка с названием "__pycache__"
В этой папке можно увидеть файлы,соответствующие модулям, которые вы импортировали.
Обычно они будут соответствовать названиям ваших модулей,например, "module1", "module2" и "simple_draw".
На прошлых занятиях мы активно с ними работали и взаимодействовали.
В папке "__pycache__" хранятся уже скомпилированные файлы,
которые были переведены в bytecode для ускорения работы.
Таким образом, Python упрощает себе задачу:он использует уже готовый bytecode для выполнения нашей программы,
что ускоряет выполнение.

Почему это важно и как это работает?
Python является интерпретируемым языком программирования,но мы пишем код на понятном
и высокоуровневом языке.
Python не переводит этот код в машинный код, который понимает компьютер.
Машинный язык — это то, на чем работает компьютер, и он сильно отличается от того, на чем пишем мы.
Чем ниже уровень языка программирования, тем ближе он к машинному языку.
Напротив, высокоуровневые языки, такие как Python, ближе к человеческому восприятию.
Например, мы пишем print и понимаем, что это действие «напечатать», в то время как машинный код
выглядит совершенно иначе и гораздо менее понятен.

Как же работает Python?
Когда мы запускаем код, интерпретатор Python сначала переводит его в bytecode.
В этом процессе помогает встроенный компилятор типа "CPython", который считается эталонным.
Этот компилятор выполняет как компиляцию, так и интерпретацию — он переводит код в bytecode,
после чего интерпретатор отвечает за выполнение на PVM (Python Virtual Machine или виртуальной машине Python).

Не будем углубляться в детали,просто имейте в виду, что перед выполнением ваша программа
проходит через несколько стадий (очень быстро).

Чтобы ознакомиться с bytecode, можно воспользоваться библиотекой "dis".
Например, мы можем использовать функцию dis из модуля "dis" и посмотреть,
каким образом представлена функция "some_func", в которой есть переменная и возврат значения из этой переменной.'''

from dis import dis


def some_func():
    a = 'Я из второго модуля'
    print('Я из второго модуля')
    return a


print(some_func())
dis(some_func)

# Я из второго модуля
# Я из второго модуля
#  47           0 RESUME                   0
#
#  48           2 LOAD_CONST               1 ('Я из второго модуля')
#               4 STORE_FAST               0 (a)
#
#  49           6 LOAD_GLOBAL              1 (NULL + print)
#              16 LOAD_CONST               1 ('Я из второго модуля')
#              18 CALL                     1
#              26 POP_TOP
#
#  50          28 LOAD_FAST                0 (a)
#              30 RETURN_VALUE


'''Воспользуемся функцией "dis" и запустим наш "module1".
При импорте модуля, весь код внутри этого модуля, выполняется.

На что следует обратить внимание?
Посмотрите на терминал для вывода:
весь код, который вы видите справа, был выполнен, и мы пришли к вызову функции "dis",
которая показывает нам, как выглядит bytecode.
Все, что вы видите в терминале, — это и есть bytecode функции "some_func"

Согласитесь, что bytecode может вызывать некоторые затруднения в понимании.
В представленном выводе мы можем увидеть, что используется переменная для быстрого хранения,
какое-то значение из второго модуля и значения, которые загружаются в глобальное пространство имен и так далее.
Эти вещи могут показаться не совсем очевидными на первый взгляд.

Тем не менее это именно то, как Python представляет код после его трансляции в bytecode.
Python изначально переводит весь написанный код в bytecode, чтобы затем его можно было эффективно выполнять.
#  1 ('Я из второго модуля')
#  0 (a)
#  6 LOAD_GLOBAL    
В файлах с расширением ".pyc", которые находятся в папке "__pycache__", хранится тот же самый bytecode.
Это означает, что Python не тратит время на повторный перевод исходного кода в bytecode во время
последующих запусков программы. Благодаря этому программа выполняется быстрее.

Вы можете переносить папку "__pycache__" на другой проект или компьютер вместе с модулями,
что облегчит задачу, но не стоит слишком заморачиваться с этим.
Это касается особенностей работы с модулями и реализации скомпилированных файлов в Python.

Пакеты
_______________
Теперь давайте перейдем к следующему вопросу — пакетам. 
Мы уже разобрались с модулями,
которые представляют собой файлы с расширением ".py", содержащие код или даже пустые файлы,
которые мы можем подключать к другим программам.
Однако, когда проекты становятся больше и объем кода увеличивается, логичнее распределять содержимое модулей
по файлам для упрощения работы над исправлениями и модификациями кода.
Это также поможет создать отказоустойчивую систему, которая будет работать более стабильно.

Когда у вас накапливается много модулей, связанных по тематике, удобнее группировать их.
Для этой цели существуют пакеты. Важно понять разницу между обычной директорией и пакетом.
Как вы видите, слева в структуре проекта есть папка "webinars" (Рис. 8).
Это просто директория. Папки такие как "Functions", "old", "output", "textfiles" и "webinars" — это обычные директории,
которые нельзя считать пакетами.
Но что же отличает пакет от обычной папки? Работают они практически одинаково.
У нас сейчас есть "module1" и "module2"
Давайте в этой папке "urbanlessons" создадим новую директорию и назовём её "modules".
И в эту директорию "modules" мы возьмём и перенесём два наших файла "module1" и "module2".
Что у нас здесь происходит? 
Мы запускаем, видим, что у нас все работает.
Но давайте создадим в папке "urbanlessons" нашей рабочей директории "module3".
У нас появилась папка, в которой находятся два модуля. 
Мы хотим их сюда импортировать, например, подключить второй модуль.
Нам уже придётся писать имя директории, то есть "from modules" (from modules import module_2)
Импортируем "module2" и запускаем "module3" .

Мы видим, что ничего не изменилось. Просто мы дополнительно указываем название модуля и название папки,
которая называется "modules".
Мы её импортировали, а именно — импортировали из неё "module2", который мы можем вывести.
Здесь мы видим какой модуль '''
# <module 'modules.module_2' from 'G:\\pyton\\lesson_md_4_5\\module_4_1\\modules\\module_2.py'>

'''Если мы зайдём в папку "modules" и затем в папку "module2", мы можем импортировать отдельную функцию,
например, "some_func" '''

# <function some_func at 0x00000277CA738CC0>
'''Запустив код, мы видим функцию и можем определить, что это конкретный объект, который хранится в памяти,
а также его bytecode с помощью функции "dis".
Это пакет, или точнее, пока это не пакет — это просто папка.
Эта папка, в принципе, ничем не отличается от модуля; 
различие заключается лишь в том, что для указания того, что мы хотим импортировать,
используется дополнительный разделитель — точка. Обратите внимание на строчку'''
# from modules.module_2 import  some_func

'''Так что же такое пакет, если папка у нас считается обычным модулем? 
Напишем "import modules", то есть мы просто импортировали папку. 
Затем напишем "print(modules)", и увидим,
что модуль с названием "modules" находится в конкретном месте в памяти'''

# import modules
# print(modules)

# <module 'modules' from 'G:\\pyton\\lesson_md_4_5\\module_4_1\\modules\\__init__.py'>

''' Мы можем взять, например, "modules" и попробовать из него что-то достать

Однако мы не видим никаких функций или классов, потому что в этом модуле нет исполняемого кода Python.
Мы просто импортировали модуль, который фактически служит контейнером для организации файлов.
По сути, это своего рода хранилище, куда мы можем поместить файлы,
чтобы затем облегчить работу с ними или упростить их поиск.


Что же такое пакет?
Пакет — это директория, которая по сути такая же, как и наша "modules".
Единственным отличием пакета от обычной папки является наличие внутри файла "__init__.py" с двойным подчеркиванием.
Когда мы создали файл "__init__.py", мы заметили, что на изображении нашей папки "modules" появился кружочек.
Этот кружочек обозначает, что наш модуль, или наша папка, теперь стала пакетом.
По сути, мы можем снова написать "import modules" и вызвать команду "print", чтобы посмотреть на него.
Мы увидим, что, как и прежде, никаких других изменений не произошло, однако теперь присутствует файл "__init__.py".

Существует особенность: 
когда мы импортируем пакет или взаимодействуем с ним, код из файла "__init__.py"
с двойным подчеркиванием начинает выполняться.
Это происходит аналогично тому, как происходит выполнение кода при импорте какого-либо модуля,
где вся информация из модуля считывается и выполняется. 
В случае с файлом "__init__.py" также считывается и выполняется код,
содержащийся в этом файле.

Давайте добавим в файл "__init__.py" строку кода: print("Я в ините в пакете модульс").
Теперь давайте запустим наш файл "module3".
Мы увидим, что код, который находился в файле "__init__.py", отобразился в нашем терминале,
и мы получили результат работы этого кода'''
# Я в ините в пакете модульс

'''На самом деле, все отличия между папкой и пакетом заключаются в этом: 
код из файла "__init__.py" выполняется при импорте пакета, 
даже если доступа к его содержимому не будет, когда мы просто импортируем модуль.
Это открывает широкий спектр возможностей для организации и инициализации кода в крупных проектах
с множеством пакетов и модулей.

При создании структуры своего проекта вы можете использовать эту особенность пакетов во благо.
Например, вы можете настроить импорты в "__init__.py" так,
чтобы при подключении какого-то пакета автоматически происходило подключение всех необходимых модулей,
выполнение каких-то вычислений или запрос данных для авторизации пользователей и так далее.
На практике разницы между обычной папкой и пакетом не существует, кроме наличия файла "__init__.py".
Чтобы создать пакет, вы можете просто добавить файл "__init__.py" в любую директорию, и она станет пакетом.

Кроме того, в большинстве IDE (интегрированная среда разработки) есть возможность создать
Python-пакет через контекстное меню:
при нажатии правой кнопкой мыши и выборе опции "New" можно выбрать
"Python Package", и IDE автоматически создаст папку с файлом "__init__.py" внутри.
Либо в существующую папку добавить файл "__init__.py",
и у вас обычная папка станет пакетом. 
В принципе, в этом то и вся разница. '''